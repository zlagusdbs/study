# MicroService

---

# According to
모건 브루스, 파울로 페레이라, 김민석 옭김., 『마이크로서비스 인 액션』, 위키북스(2019)

# 1. 마이크로서비스 설계하고 실행하기
## 1.1. 마이크로서비스 애플리케이션이란 무엇인가?
- 자율적인 서비스의 집합
  - 각각의 서비스는 한 가지 일을 하고, 그 서비스들이 협업해 좀 더 복잡한 작업을 수행
  - 즉, 높은 응집력과 느슨한 결합력을 강조

    - 응집력: 특정 모듈의 내부 구성요소의 결속 정도
    - 결합력: 특정 모듈의 한 요소가 다른 모듈의 내부 동작을 아는 정도
      - 로버트 마틴의 단일 책임 원칙(같은 이유로 변경되는 것을 함께 모아라. 다른 이유로 변경되는 것은 분리하라)과 같다.

### 1.1.1. 분해를 통한 확장
- 애보트, 피셔., 『The Art of Scalability, Addison-Wesley Professional(2015)』에서 확장 큐브를 사용해 확장의 3가지 차원을 정의

- X축: 복제를 위한 확장
- Y축: 다른 것을 분리한 확장
- Z축: 비슷한 것을 분리해 확장(ex> 샤딩과 같은 수평적 데이터 파티셔닝)
  - 모놀리식 애플리케이션과 마이크로 서비스 모두에 적용가능

### 1.1.2. 핵심원칙
- 자율성: 다른 서비스와 독립적으로 변경되고 운영
  - 13장에서 책임과 자율성을 가진 엔지니어링팀 구성하기와 왜 이것이 마이크로서비스를 다룰 때 중요한지 논의
- 회복성: 마이크로 서비스를 독립적으로 배포하면 애플리케이션 또는 인프라스트럭처의 장애는 시스템의 일부에만 영향을 미치도록 한다.
- 투명성: 언제 장애가 발생했는지 아는 것. 이를 위해 매트릭과 로그, 그리고 요청 추적을 생성해야 한다.
- 자동화: 정확한 배포와 운영을 보장하도록 자동화를 적용해야 한다.
- 동기화: 서비스가 비즈니스 컨셉과 일치하도록 팀도 같은 생각으로 동기화 되어야 한다.

## 1.2. 무엇이 마이크로서비스를 어렵게 만드는가 ?
### 1.2.1. 설계상의 어려움
- 마이크로서비스의 범위를 정하는 것은 도메인 지식을 요구한다.
- 서비스 간 계약 유지하기
  - 완정성: 상화작용의 완전한 범위를 정의
  - 충분성: 필요 이상의 정보를 제거해 메시지 소비자가 적절한 범위에서 메시지를 구성할 수 있게 한다
  - 예측성: 모든 구현의 실제 행동을 정확한게 반영
- 마이크로서비스 애플리케이션은 여러팀이 설계
- 마이크로서비스 애플리케잇녀은 분산 시스템

### 1.2.2. 운영상의 도전 과제
- 관측 가능성은 달성하기 어렵다
- 서비스가 많아지면 장애 지점도 증가한다

### 1.3. 마이크로서비스 개발 라이프사이클
- 마이크로서비스 설계하기
- 모놀리식 애플리케이션으로 시작할 것인가?
- 서비스 범위 정하기
- 커뮤니케이션
  - 서비스간 커뮤니케이션을 뜻 하며, 동기식과 비동기식이 있다. 
- 회복성

### 1.3.2. 마이크로서비스 배포하기
- 마이크로서비스 배포 산출물 표준화
- 지속 전달 파이프라인 구현하기

### 1.3.3 마이크로서비스 관찰하기
- 잠재적으로 깨지기 쉬운 구현을 식별하기 리팩터하기
- 수백 개의 서비스에 걸친 동작 이해하기

### 1.4. 운영에 대해 인지하고 책임지는 엔지니어링 문화

# 2. 마이크로서비스 적용사례
## 2.3. 새로운 기능을 개발하기
- 심플뱅크라는 예제를 가지고 새로운 기능이 추가했을 때를 대비하여 논의한다.

### 2.3.2. 서비스 간의 협업
- 서비스계약
  - 각 서비스가 수신하고 응답하는 메시지는 서비스에 의존하는 상위 조율 서비스와 계약을 형성한다.
  - 서비스의 구현은 시간이 지남에 따라 변경될 수 있지만, 컨트랙트 수준에서 호환성을 유지하려면 다음 2가지를 보장해야 한다.
    - 변경이 컨슈머에 장애를 일으키지 않아야 한다.
    - 서비스 간 의존성을 명확하게 식별하고 관리할 수 있어야 한다.
- 서비스책임
  - 하나의 서비스가 처리의 결과를 동기화된 방식으로 확인할 필요가 없이 요청을 받기만 해도 좋타면 이후의 하위 처리에 대해서는 알 필요가 없다.

### 2.3.3. 서비스의 자율적 구성

## 2.4. 서비스를 외부에 노출하기
- API 게이트웨이 패턴은 우아하지만 몇 가지 단점이 있다.
  - API 게이트웨이는 여러 서비스를 위한 단일 구성 지점의 역할을 함으로, 점차 커지거나 다루기 어려워진다.
  - 이것은 독립적인 프락시로 다루는 대신 비즈니스 로직을 추가하고 싶은 유혹에 빠지기 쉽다.
- 3장에서 API 게이트웨이에 대한 논의를 다시 할 예정

## 2.5. 운영 환경에 기능 반영하기
- 버스 팩터(팀원들 간에 공유되지 않은 지식의 위험척도로 버스 팩터가 낮으르 수록 나쁘다.) 수치를 높여야 한다.

### 2.5.1. 품질 관리와 자동 배포
- 표준화와 자동화로 배포를 할 수 있도록 유도 하자는 글귀

### 2.5.2. 회복성
### 2.5.3. 투명성

# 3. 마이크로서비스 애플리케이션의 아키텍처
## 3.1. 전체 아키텍처

## 3.2. 마이크로서비스 플랫폼
### 3.2.1. 운영 플랫폼 매핑
Micro Service Architecture  
![MicroService Architecture](../Resource/Infra%2C%20Micro%20Service%2C%20MicroService%20Architecture/%EC%8A%AC%EB%9D%BC%EC%9D%B4%EB%93%9C1.PNG)


## 3.3. 서비스
### 3.3.1. 역량
- 비즈니스 역량: 가치를 창출하고 비즈니스 목표를 만족하기 위해 조직이 수행하는 것
- 기술적 역량: 공유된 기술적 기능을 구현해 다른 서비스를 지원한다.

### 3.3.2. 집계 및 상위 주문 서비스
- 마이크로서비스 애플리케이션의 초기에는 서비스의 계층이 평평할 것이다.
- 즉, 각 서비스가 비슷한 수준의 책임을 갖는다.
- 시간이 지나면서 서비스의 계층을 형성시킬 것이다.
  - 집계자(Aggregator): 하위 서비스로 질의하여 데이터를 모으는 역활
  - 조율자(Coordinator): 하위 서비스로 명령을 요청해 행동을 조율

### 3.3.3. 중요 경로와 중요하지 않은 경로

## 3.4. 커뮤니케이션
### 3.4.1. 언제 동기식 메시지를 사용하는가
- 다음 작업을 시작하기 전에 현재 작업의 결과 또는 성공/실패를 아는 시나리오에 적합
- 단점
  - 서비스가 반드시 협력자를 알아야 함으로 서비스 간에 단단한 결합력이 생긴다.
  - 강력한 브로드캐스트 모델 또는 게시-구독 모델이 없어서 병렬 작업을 수행하는 데 제약이 있다.
  - 응답을 기다리는 동안 코드 수행을 멈춘다. 스레드 또는 프로세스 기반 서버 모델에서 이 모델은 용량을 고갈시키고 장애를 전파시킬 수 있다.
  - 과도한 동기식 메시지 사용은 깊은 의존성 체인을 만들어서 전반적인 호출 경로의 장애 가능성을 증가시킬 수 있다.

### 3.4.2. 언제 비동기식 메시지를 사용하는가
- 서비스 간 좀 더 유연한 발전을 가능하게 하고 느슨한 결합을 생성한다.
- 단, 많은 비용을 수반하며, 서비스 간 상호작용을 예측하기 어려워짐으로 모니터링 시스템에 투자를 많이 해야 한다.
- 일반적으로 비동기 메시징은 이벤트를 수신하고 이벤트 컨슈머에게 전달하는 독립적인 구성요서인 커뮤니케이션 브로커를 요구한다.(이것은 종종 시스템에서 중심적인 역활을 강조하는 의미로 이벤트 백본이라고도 불리운다)

### 3.4.3. 비동기식 커뮤니케이션 패턴
- 잡 큐
  - 하나의 서비스에서 이벤트를 발행하면, 다른 서비스에서 이벤트를 꺼내어 작업을 진행하는 방식
  - 저장 큐로는 레디스, 셀러리, 사이드킥 또는 SQL 데이터베이스와 같은 일반적인 저장소를 사용
- 게시-구독
  - 하나의 서비스에서 이벤트를 발행하면, 임의의 리스너를 통해 이벤트를 꺼내어 작업을 진행하는 방식

### 3.4.4. 다른 서비스 찾기
- 서비스 디스커버리
  - 서비스는 커뮤니케이션 하기 위해 서로를 발견 해야 한다.
  - 이를 위해 컨설(Consul, https://consul.io)과 같은 레지스트리를 사용할 수 있다.
  
  > TODO: 서비스 디스커버리에 대한 상세한 설명이 없다. 이것을 별도로 학습해야 할 것 같다.

## 3.5. 애플리케이션 경계
- 경계 계층은 내부 서비스와 복잡한 상호작용을 할 수 있는 Facade를 제공한다.

### 3.5.1. API 게이트웨이
- API 게이트웨이가 여러 애플리케이션의 구성 지점으로 작동하면 점점 더 많은 책임을 지기 시작한다.

> 매셰이프(Mashape), 콩(Kong)과 같은 오픈 소스와 AWS API 게이트웨이와 같은 상용제품이 있다. 

### 3.5.2. 프런트엔드를 위한 백엔드(BFF: Backends For Frontends)
- API 게이트웨이 패턴을 각 클라이언트 유형에 맞게 각각 두는 것을 말한다.

### 3.5.3. 컨슈머-주도 게이트웨이
- BFF 접근 방식을 발전시켜, 여러 API를 개발하는 대신 컨슈머가 필요한 응답의 형태를 정의할 수 있게 해주는 '슈퍼세트'API를 구축하자는건데..
- 이를 위해 GraphQL을 사용하자는 것.
> 그런데... 이게 서버to서버에서 응용이 될지.. 그리고 API 게이트웨이 패턴의 개선과 연관이 있는지 감이 잡히지 않는다.

## 3.6. 클라이언트

# 4. 신규 기능 설계하기
- 심플뱅크라는 예제를 주고, 신규 기능을 설계하는 과정에 대한 설명을 진행한다.
- 요약
  - 도메인 지식을 고수준으로 습득할 것
  - 유스케이스로 범위 지정해볼 것
  - 기술적 역량을 기를 것
  - 조직의 서비스 오너십을 갖을 것

# 5. 마이크로서비스에서의 트랙잭션과 질의
## 5.1. 분산 애플리케이션에서 일관된 트랜잭션
- 모놀리식 애플리케이션의 ACID 트랜잭션에서 데이터베이스 동작을 감싸고 잘못된 상태를 유발하는 에러는 원래 상태로 되돌아 갈 것을 알 수 있다.
- 다만, 마이크로서비스 애플리케이션에서 각 동작은 애플리케이션 상태의 일부를 담당하는 명확한 서비스에 의해 수행된다.

### 5.1.1. 왜 분산 트랜잭션을 사용할 수 없는가?
- 여러 서비스에 결처 트랜잭션을 보장할 수 있도록 시스템을 설계할 수 있다.

- 2PC(two-phase commit)이다.
  - 단, 이 방식은 동기식 커뮤니케이션을 기반으로 하며, 시스템 전체의 가용성을 떨어뜨린다.
- lock
  - 단, 서비스들 간의 경쟁과 데드락(deadlock)의 위험을 증가시킨다.

## 5.2. 이벤트 기반 커뮤니케이션
- 시스템에 궁극적 일관성을 적용하는 것은 시간의 경과에 따라 여러 독립적인 로컬 트랜잭션의 결과로부터 복잡한 결과를 내도록 설계하는 것이므로 하위 리소스를 설계할 때 명시적으로 잠정적인 상태를 나타내도록 한다.
- 에릭 부루어(Eric Brewer)의 CAP 이론의 관점에 따르면 이 설계 방식은 하위 데이터의 가용성에 우선순위를 둔다.
  - CAP: Consistency(일관성), Availability(가용성), Partition Tolerance(파티션 내성)

## 5.3. 사가(Saga) 패턴
### 5.3.1. 자율적으로 구성된 사가 패턴
- 각각의 서비스는 Tx를 처리할 때, 보상 트랙잭션의 정보도 알고 있어야 한다.

### 5.3.2. 조율된 사가 패턴
- Aggregator 서비스를 두고, 하위 서비스들을 호출해 가면서 Tx를 진행한다.

### 5.3.3. 중첩된 사가 패턴
- ACID 트랜잭션과 다르게 사가는 격리(isolation)가 없다.
- 그래서 중간 상태를 예상하고 다루도록 비즈니스 로직을 설계해야 한다.

- 회로차단기
  - Tx1을 진행할 때, Tx2를 진행 할 수 없도록 제한한다.

- 잠그기
  - Tx1을 진행할 때, 동일한 Tx1(double submit 등)의 요청이 올 경우, locking하여 제한한다.
  - 단, 데드락의 위험을 피할 수 없다.

- 인터럽트
  - 동작이 실행되는 것을 방해하도록 한다.
  - 예를 들어 주문 상태를 '실패'로 갱신하고, 다른 서비스에서 '실패' 상태를 확인하고 추가 진행을 못하도록 한다.
  - 단, 이것은 비즈니스 로직의 복잡도를 증가시킬 수 있다.

### 5.3.4. 일관성 패턴
- 보상동작: 이전 동작을 없던 일로 하는 동작을 수행
- 재시도: 성공 또는 시간 만료될 때까지 재시도
- 무시: 에러 이벤트가 발생해도 아무것도 하지 않는다.
- 재시작: 원래 상태로 초기화하고 다시 시작한다.
- 잠정적 동작: 잠정적 동작을 수행하고 나중에 확정 또는 취소한다

### 5.3.5. 이벤트 소싱
- 닉 체임벌린(Nick Chamberlain)의 awesome-addd 목록(https://github.com/heynickc/awesome-ddd)

## 5.4. 분산된 환경에서의 질의
- 분산된 데이터 소유권은 데이터 조회를 더욱 어렵게 한다.
- 조인처럼 데이터베이스 수준 또는 근접한 수준에서 관련된 데이터를 집계하는 것이 더이상 불가능하기 때문
- 더불어 한개 또는 작은 데이터 세트에서는 잘 작동하지만, 대량 요청에는 제대로 성능을 확장하지 못한다.
- 대용량 요청 종단점과 페이징(Paging) 기법으로 개선할 수 있지만, 이 역시 완벽하지 않다.

### 5.4.1. 데이터 복제본 저장하기

### 5.4.2. 질의와 명령 분리하기
- CQRS 아키텍처
![CQRS 아키텍처](../Resource/Infra%2C%20Micro%20Service%2C%20MicroService%20Architecture/%EC%8A%AC%EB%9D%BC%EC%9D%B4%EB%93%9C2.PNG)

### 5.4.3. CQRS의 어려운 점
- 이벤트가 질의 모델을 갱신하기 때문에 누군가 그 데이터를 조회하면 만료된 뷰를 보게 된다.
- 다만, 어떤 시스템에서는 이것이 문제가 되지 않는다. 다만, 일관성 없는 상태를 질의하지 못하게 하는 것이 중요한 시스템이 있다.

#### Resolved 
- 낙관적 갱신(Optimistic updates)
  - 클라이언트는 서버가 Tx가 성공할 것임을 예측하여 진행한다.
  - 이후 실패 시, 클라이언트는 변경을 취소하고 다시 Tx를 요청해야 한다.
  - ex> Instagram에서 게시글의 '좋아요' 가능
- 폴링(Polling)
  - 클라이언트는 서버로 지속해서 성공/실패 여부를 요청한다.
- 게시-구독(Publish-subscribe)
  - 클라이언트가 서보로 폴링하는 대신, 리스너를 두어 완료 이벤트를 구독한다.

### 5.4.4. 분석과 리포팅

# 6. 실뢰할 수 있는 서비스 설계하기
## 6.2. 잠재위험 찾아내기
### 6.2.1. 장애의 원인
- 하드웨어
- 커뮤니케이션
- 의존성
- 서비스 실무

### 6.2.2. 장애의 전파

## 6.3. 신뢰할 수 있는 커뮤니케이션 설계하기
- 재시도
- 폴백
  - 우아한 저하: 에러난 부분을 제외한 데이터만 보여준다.
  - 캐싱: 캐싱된 데이터(갱신되진 않음)를 보여준다.
  - 기능 중복: 같은 기능을 가진 서비스를 찾아 요청을 다시 보낸다.
  - 대체 데이터: 빈 값을 보여주거나 다른 문구를 보여주는 방법도 있다.
- 타임아웃과 데드라인
- 회로 차단기
  - 실무에서 사용하는 Circuit Breaker에 대한 설명이다.
- 커뮤니케이션 브로커

### 6.3.5. 비동기 커뮤니케이션

## 6.4. 서비스 신뢰성 극대화하기
결국 LB에 대한 설명인데.. 이것은 나중에 필요할 때 정확히 학습하고 기록하자..

# 7. 재사용할 수 있는 마이크로서비스 프레임워크 구축하기
## 7.1. 마이크로서비스 섀시
- 개발환경에 대해 의논하고 정의하는 것으로, Saturn, RMS 등이 있다.
- 어떤 팀이 서비스를 소유하더라도 모든 서비스가 따라야 할 표준을 제공하면서 서비스를 쉽게 생성할 수 있게 도와주는 것.

# 8. 마이크로서비스 배포하기

# 9. 컨테이너와 스케줄러를 이용해 배포하기

# 10. 마이크로서비스 전달 파이프라인 구축하기

# 11. 모니터링 시스템 구축하기
> 이것은 프로메테우스, 그라파나를 학습하는게 더 낫겠다.

# 12. 로그와 추적 정보로 동작 이해하기
## 12.1. 서비스 간의 작동 이해하기
## 12.2.1. 로그에 포함할 유용한 정보
- 타임스탬프
- 식별자
- 소스
- 레벨 또는 카테고리

### 12.2.2. 구조와 가독성
> 로그스태시
>> 로그스태시는 여러 소스에서 이벤트와 로그 메시지를 수집, 처리, 전달하는 도구이다.  
>> 데이터 수집을 구성하기 위한 다양한 플러그인을 제공한다.  

## 12.3. 심플뱅크를 위한 로깅 인프라스트럭처 구축하기
### 12.3.1. ELK와 플루언트디 기반 솔루션
- 엘라스틱서치
- 로그스태시
- 키바나
- 플루언트디

## 12.4. 서비스 간 상호작용 추적하기
### 12.4.1. 요청 연관 짓기: 트레이스와 스팬

# 13. 마이크로서비스 팀 구성하기
